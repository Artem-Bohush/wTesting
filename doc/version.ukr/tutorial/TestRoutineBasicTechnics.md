# Техніка розробки тестів

Описано базові навички написання тест рутин та найпоширеніші помилки.

При написанні тест рутини слід орієнтуватись на приведену інформацію. Описані техніки показують як підвищити якість покриття та зберегти зручність роботи з тест рутиною.

Перелік технік і прийомів:

- Вибір назви тест рутини
- Покроковість створення тест рутини
- Окремі змінні для тест кейсу
- Що перевіряється чи яким має бути результат тест кейсу
- Опис різниці між тест кейсами
- Тест кейс тестує один з аспектів тест юніта
- Збитковість тест кейсів
- Збитковість тест перевірок
- Збитковість вхідних даних
- Нечитабельні дані ( антипатерн )
- Розміщення змінних на початку або в кінці ( антипатерн )
- Використання структур даних і циклів ( антипатерн )
- Функціональні адаптери ( антипатерн )

### Вибір назви тест рутини

Якщо покриття тест юніта має незначний об'єм, то назва тест юніта і тест рутини мають співпадати. Це дозволяє зрозуміти який тест юніт тестується.

Деякі тест юніти мають значну кількість комбінацій аргументів і опцій, що потребують розділення тестового покриття на окремі тест рутини. В такому разі зменшення об'єму окремої тест рутини робить її більш зручною для підтримки. Навігація по тестовому покриттю стає швидшою адже спрощуєтсья пошук необхідного тест кейсу. Якщо покриття тест рутини ділиться на окремі тест рутини, тоді назви тест рутин повинні починатись з назви тест юніта та містити додаткову приставку, що пояснює особливість тест рутини.

Наприклад, в модулі [`Tools`](https://github.com/Wandalen/wTools) є рутина `strSplitInlined` котра ділить рядок за обраним розділювачем. Рутина має близько 10 опцій котрі впливають на результат. Серед опцій є такі як `delimeter` - визначає розділювач за яким ділиться рядок, `stripping` - керує видаленням пробільних символів для частин рядка.

Поганою практикою є використання незрозумілих назв для тест рутини. Наприклад додавання індексу до тест рутини.

```
strSplitInlined1
strSplitInlined2
```

Хорошими назвами для тест рутин будуть подібні до вказаних

```
strSplitInlinedDefaultOptions,
strSplitInlinedOptionDelimeter,
strSplitInlinedOptionStripping,
```

Проглянувши назву окремої тест рутини стає зрозуміло вплив яких опцій досліджується.

### Покроковість створення тест рутини

При створенні покриття для тест юніта слід орієнтуватись на його призначення і загальні особливості функціонування. При цьому сам процес написання краще починати з базових випадків поступово ускладнюючи тест рутину.

Наприклад, рутина `arrayRemove`, котра видаляє указаний елемент з масиву. Порядок наповнення такої тест рутини може бути таким:
- видалення елементу з порожнього масиву;
- видалення елементу з масиву, який не містить елементу з потрібним значенням;
- видалення елементу з масиву, що містить декілька елементів з потрібним значенням;
- видалення елементу з масиву, що містить лише елементи з указаним значенням;
- подальші ускладнення тест рутини використанням складних типів та колбеків.

Приклад [покрокового створення тест рутини `numberIs`](./TestRoutineStepByStep.md#Тести-що-перевіряють-штатну-поведінку).

### Окремі змінні для тест кейсу

Для окремих тест кейсів мають використовуватись власні змінні. Це дозволяє ізолювати окремий тест кейс і тестувати його окремо.

```js
test.case = 'src is positive integer';
var src = 5;
var got = _.numberIs( src );
var expected = true;
test.identical( got, expected );

test.case = 'src is negative integer';
var src = -1 * src;
var got = _.numberIs( src );
test.identical( got, expected );
```

Приведений приклад показує два тест кейси. Перший з них має власні змінні `src`, `expected`, змінні і результат такого тест кейсу повністю незалежні. Другий тест кейс має змінну `src` котра використовує значення однойменної змінної із попереднього тест кейса. Також, тест залежний тест кейс використовує змінну `expected` незалежного тест кейса. Залежний тест кейс неможливо протестувати окремо від його залежностей. Якщо попередній тест кейс зміниться, або буде видалений, то результат залежного тест кейса зміниться, а може навіть викинути помилку.

### Що перевіряється чи яким має бути результат тест кейсу

Опис тест кейсу чи тест перевірки має явно вказувати на те, що перевіряється, чи яким має бути результат перевірки.

```js
test.case = 'null, null';
var got = _.arrayAppend( null, null );
var expected = [ null ];
test.identical( got, expected );
```

Рутина `arrayAppend` приймає два аргументи - `dst` i `ins`, вона додає другий аргумент в кінець масиву `dst`. Якщо `dst` має значення `null`, тоді створюється новий масив. Приведений тест кейс має поганий опис по двом причинам. По перше, з опису незрозуміло що перевіряється, чи які умови імплементовано. По друге, за можливості для опису краще використовувати не окремі значення, а цілі категорії.

Для приведеного тест кейсу опис може бути таким

```js
test.case = 'dst is null, ins is primitive';
```

Тест кейс описує умови тестування, тобто, що тестується. В назві явно указано назви аргументів, що полегшує зчитування інформації. Для аргументу `ins` використана категорія `primitive`, при заміні значення `null` на інший примітив результат буде аналогічним.

Опис тест кейсу може містити опис очікуваного результату

```js
test.case = 'dst is null, primitive appends to new container';
```

Для окремої тест рутини стиль опису має бути однаковим. Це дозволяє швидко орієнтуватись у послідовності тест кейсів.

### Опис різниці між тест кейсами

Опис окремих тест кейсів має вказувати на відмінність між конкретним тест кейсом від інших.

```js
test.case = 'range[ 0 ] - 0, range[ 0 ] < range[ 1 ]';
// code of test case

test.case = 'range[ 0 ] - 0, range[ 0 ] === range[ 1 ]';
// code of test case
```

Приведені вище описи демонструють відмінність у умовах проведення тесту. В описі є спільна частина котра вказує на приналежність до певної групи тест кейсів. Для опису використовуються категорії `більше` і `рівно` що в даному випадку не потребують уточнень.

```js
test.case = 'expects empty array';
// code of test case

test.case = 'saves 2 elements from start';
// code of test case
```

Відмінність між тест кейсами може бути описана в очікуваному результаті. В першій перевірці очікується порожній масив, а в другому має лишитись 2 елементи. При описі результату початкові умови задаються раніше, вони доступні і їх просто зрозуміти.

### Тест кейс тестує один з аспектів тест юніта

Кожен тест кейс тестує лише один з аспектів тест юніта. Поганою практикою є змішування двох тест кейсів в одному.

```js
test.case = 'expects empty array';
var dst1 = [];
var dst2 = [ 1, 1, 1 ];
var got = _.arrayRemove( dst1, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst1 );
var got = _.arrayRemove( dst2, 1 );
test.identical( got, expected );
test.is( got === dst2 );
```

Приведений тест кейс демонструє змішування двох тест кейсів. В обох очікується однаковий результат. Такий тест кейс складно читати, подібність викликів і отриманих результатів дезорієнтує. Тест кейс має бути розділеним:

```js
test.case = 'dst is empty array, expects empty array';
var dst = [];
var got = _.arrayRemove( dst, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst );

test.case = 'dst contains only searched element, expects empty array';
var dst = [ 1, 1, 1 ];
var got = _.arrayRemove( dst2, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst2 );
```

Кожен тест кейс тестує одну із можливих ситуацій. Тест рутину легко читати і підтримувати.

Маркерами того, що йде змішування декількох тест кейсів є використання додаткових змінних, індексування змінних подібно указаним приставкам `dst1` i `dst2`, а також використання додаткових рутин для перевірки результату.

### Збитковість тест кейсів

Збитковість ( надлишковість ) - створення і використання непотрібного коду.

Збитковість тест кейсів проявляється у випадках, коли багаторазово тестуються однотипні дані.

```js
test.case = 'src is 5';
var src = 5;
var got = _.numberIs( src );
var expected = true;
test.identical( got, expected );

test.case = 'src is 1000';
var src = 1000;
var got = _.numberIs( src );
var expected = true;
test.identical( got, expected );
```

Приведений код показує як проявляється збитковість тест кейсів. Рутина `numberIs` перевіряє чи є переданий аргумент числом. Очевидно, що `5` i `1000` це різні числа. Одночасно, обидва аргументи відносяться до цілочисленних позитивних чисел, а тому достатньо використати один тест кейс. Для тестування важливо розділяти окремі вхідні дані і категорії даних. Без цього збитковість тест кейсів збільшується.

### Збитковість тест перевірок

Збитковість тест перевірок проявляється в використанні додаткових перевірок, що не мають сенсу в представленому контексті.

```js
test.case = 'dst is null, ins is primitive';
var dst = null;
var ins = 'str';
var got = _.arrayAppend( dst, ins );
var expected = [ 'str' ];
test.identical( got, expected );
test.is( got !== dst );
test.is( got !== ins );
test.is( got[ 0 ] === ins );
```

Приведений тест кейс має три зайвих тест перевірки. Перевірка `identical` перевіряє чи є повернене значення масивом з поміщеним всередину примітивом. Наступна перевірка `is` перевіряє чи виконується умова `got !== dst`. Якщо вже перевірено, що результат це масив, то немає сенсу порівнювати `null` і масив. Аналогічна ситуація з наступною перевіркою де рядок порівнюється з масивом. Остання перевірка може мати сенс, якщо додане значення не примітив. Наприклад, якщо `ins` це масив, тоді можна перевірити чи не створила рутина копію.

### Збитковість вхідних даних

Для тест юнітів, котрі працюють з контейнерами, необхідно вибирати такий об'єм контейнера, щоб було зручно читати. При цьому, якість покриття має бути на високому рівні.

Досить часто для тестування вибираються надлишкові дані, що сповільнюють тестування і погіршують роботу з кейсом.

```js
test.case = 'remove single element';
var dst = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
var got = _.arrayRemove( dst, 3 );
var expected = [ 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
```

В прикладі використовується рутина `arrayRemove` котра видаляє указаний елемент з масиву. Вхідний масив містить 10 елементів, а видаляється один. Порівняння вхідних даних з очікуваним результатом ускладнене через велику кількість однотипних елементів. Для подібних тест кейсів достатньо обрати 3-5 елементів.

```js
test.case = 'remove single element';
var dst = [ 1, 2, 3, 4 ];
var got = _.arrayRemove( dst, 3 );
var expected = [ 1, 2, 4 ];
```

Виправлений приклад дозволяє відразу прочитати дані не зосереджуючись на непотрібних деталях.

### Нечитабельні дані ( антипатерн )

Вхідні дані і дані для перевірки повинні легко читатись.

Часом при розробці тест кейсів розробник вибирає дані, які складно аналізувати. Один з аспектів - надлишкові дані, котрі погіршують аналіз. Але деякі тест кейси потребують значного об'єму вхідних або вихідних даних. В такому разі важливо правильно відформатувати код.

```js
test.case = 'full uri with all components, primitiveOnly';

var uri = 'http://www.site.com:13/path/name?query=here&and=here#anchor';
var expected =
{
  'protocol' : 'http',
  'host' : 'www.site.com',
  'port' : 13,
  'localWebPath' : '/path/name',
  'query' : 'query=here&and=here',
  'hash' : 'anchor',
  'longPath' : 'www.site.com:13/path/name',
  'protocols' : [ 'http' ],
  'hostWithPort' : 'www.site.com:13',
  'origin' : 'http://www.site.com:13',
  'full' : 'http://www.site.com:13/path/name?query=here&and=here#anchor'
}
var got = _.uri.parseFull( uri );
test.identical( got, expected );
```

Рутина `parseFull` модуля [`Uri`](https://github.com/Wandalen/wUriBasic) парсить переданий шлях на складові. Результат, що очікується має гарне форматування - кожне поле займає окремий рядок, тому будь-яке поле легко знайти і прочитати.

Іноді деякі дані предтавляються у вигляді, що легко пропустити.

```js
test.case = 'unreadable expected variable';
var got = _.arrayMake( 3 );
var expected = [ ,, ];
test.identical( got, expected );
```

Очікуваний результат візуально нагадує порожній масив. Використання порожніх елементів замість `undefined` погіршує роботу з тест кейсом.

### Розміщення змінних на початку або в кінці ( антипатерн )

Розміщення змінних на початку або в кінці рутини небажане. Це погіршує читабельність тест рутини і потребує постійної навігації між тест кейсом та місцем об'явлення змінних.

```js
function prefixGet( test )
{
  var path1 = '',
      path2 = 'some.txt',
      // other paths
      expected1 = '',
      expected2 = 'some',
      // other expected values

  /* */

  test.case = 'empty path';
  var got = _.path.prefixGet( path1 );
  test.identical( got, expected1 );

  test.case = 'txt extension';
  var got = _.path.prefixGet( path2 );
  test.identical( got, expected2 );

  // other test cases
```

Представлений код показує випадок, коли змінні розміщені на початку тест рутини. Для такого короткого коду розробнику потрібно більше часу щоб проаналізувати тест кейс і співставити вхідні дані з отриманим результатом. При збільшенні тест рутини необхідна додаткова навігація або потрібно більше розумових зусиль для запам'ятовування малозначимої інформації.

Виключенням із цього антипатерну є створення контексту виконання тест рутини. Контекстом тест рутини можуть бути колбеки, інстанси класів котрі не змінюються або створюють спеціальні умови виконання тест рутини.

```js
function srcOnly( filePath, it )
{
  if( filePath === null )
  _.assert( 0 );

  if( it.side === 'dst' )
  return '';
  return filePath;
}
```

Дублювання такого колбеку не додає зручності використання рутини, проте погіршує читабельність.

### Використання структур даних і циклів ( антипатерн )

Розробник може помістити якісь однотипні дані в структуру ( масив, мапу ) і провести тестування скопом. Цей підхід об'єднує в собі декілька негативних рис. Перша полягає в погіршенні читабельності рутини. Для кожного тест кейсу потрібно співвідносити дані в структурі і процедуру виконання тест кейсу. Друга - в тому, що в разі виникнення помилки, погіршується інформативність сервісної інформації. В такому випадку багаторазово повторюється однаковий вивід.

```js
var src =
[
  null,
  undefined,
  1,
  // ohter elements
];

for( let i = 0 ; i < src.length ; i++ )
{
  test.case = `src - ${ typeof src[ i ] }, expected - false`;
  var got = _.strIs( src[ i ] );
  test.identical( got, false );
}
```

Приклад показує використання циклу для масиву вхідних даних. Тест погано читається. При ускладненні тест юніта використання циклів погіршує підтримку тест рутини.

### Функціональні адаптери ( антипатерн )

Для виконання ряду перевірок, дані в яких приводяться до деякого виду, розробник може створити функціональний адаптер з тест перевіркою.

```js
function eq( ins1, ins2 )
{
  test.identical( Math.abs( ins1 - ins2 ) < epsilon );
}
```

Функція `eq` - функціональний адаптер для перевірки того, що різниця двох отриманих значень не більше похибки. Використання функціонального адаптера замість прямої перевірки даних зменшує інформативність сервісної інформації у разі виникнення ряду помилок. При виникненні помилки вивід міститиме указання на рядок з функціональним адаптером, а не на тест кейс з даними. Пошук несправності в тест рутині з функціональними адаптерами ускладнюється.

### Підсумок

- Для вибору назви тест рутини слід орієнтуватись на назву тест юніта та особливості тест кейсів поміщених в тест рутину.
- Покрокове створення покриття дозволяє врахувати всі важливі сценарії виконання.
- Тест кейси рутини мають бути незалежними один від одного.
- Опис тест кейсу має пояснювати що тестується чи яким має бути результат. При цьому опис має пояснювати чим даний тест кейс відрізняється від інших.
- Окремий тест кейс тестує лише один сценарій тест юніта.
- Розширення покриття тест юніта за рахунок збільшення збитковості тест кейсів чи тест перевірок призводить до значних втрат часу на написання тест рутини, а також на її виконання.
- Дані комплексних структур даних, що використовуються в тест кейсах мають бути оптимального об'єму. Збільшення об'єму даних незначно покращує покриття, але погіршує роботу з тест кейсом.
- Дані котрі потребують значного об'єму бажано правильно відформатувати. При цьому пришвидшується робота з тест рутиною.
- Змінні для тест кейсу повинні міститись в самому тест кейсі. В такому разі розробнику не потрібна навігація по тест рутині і запам'ятовування значень змінних.
- Контекст тест рутини може бути об'явлений одноразово на початку або в кінці.
- Поміщення змінних в структури даних і перебір в циклі ускладнює роботу з окремим тест кейсом. У випадку виникнення ряду помилок сервісна інформація стає менш інформативною.
- Слід використовувати прямі перевірки отриманих результатів, в такому разі сервісна інформація буде точною.

[Повернутись до змісту](../README.md#Туторіали)
