# Базові техніки

Описано основні особливості тест рутин та найпоширеніші помилки при їх написанні.

Перелік технік і прийомів:

- Вибір назви тест рутини
- Покроковість створення тест рутини
- Окремі змінні для тест кейсу
- Що перевіряється чи яким має бути результат тест кейсу
- Тест кейс тестує один з аспектів тест юніта

### Вибір назви тест рутини

Якщо покриття тест юніта має незначний об'єм, то назва тест юніта і тест рутини мають співпадати. Це дозволяє зрозуміти який тест юніт тестується.

Деякі тест юніти мають значну кількість комбінацій аргументів і опцій, що потребують розділення тестового покриття на окремі тест рутини. В такому разі зменшення об'єму окремої тест рутини робить її більш зручною для підтримки. Навігація по тестовому покриттю стає швидшою адже спрощуєтсья пошук необхідного тест кейсу. Якщо покриття тест рутини ділиться на окремі тест рутини, тоді назви тест рутин повинні починатись з назви тест юніта та містити додаткову приставку, що пояснює особливість тест рутини.

Наприклад, в модулі [`Tools`](https://github.com/Wandalen/wTools) є рутина `strSplitInlined` котра ділить рядок за обраним розділювачем. Рутина має близько 10 опцій котрі впливають на результат. Серед опцій є такі як `delimeter` - визначає розділювач за яким ділиться рядок, `stripping` - керує видаленням пробільних символів для частин рядка.

Поганою практикою є використання незрозумілих назв для тест рутини. Наприклад додавання індексу до тест рутини.

```
strSplitInlined1
strSplitInlined2
```

Хорошими назвами для тест рутин будуть подібні до вказаних

```
strSplitInlinedDefaultOptions,
strSplitInlinedOptionDelimeter,
strSplitInlinedOptionStripping,
```

Проглянувши назву окремої тест рутини стає зрозуміло вплив яких опцій досліджується.

### Покроковість створення тест рутини

При створенні покриття для тест юніта слід орієнтуватись на його призначення і загальні особливості функціонування. При цьому сам процес написання краще починати з базових випадків поступово ускладнюючи тест рутину.

Наприклад, рутина `arrayRemove`, котра видаляє указаний елемент з масиву. Порядок наповнення такої тест рутини може бути таким:
- видалення елементу з порожнього масиву;
- видалення елементу з масиву, який не містить елементу з потрібним значенням;
- видалення елементу з масиву, що містить декілька елементів з потрібним значенням;
- видалення елементу з масиву, що містить лише елементи з указаним значенням;
- подальші ускладнення тест рутини використанням складних типів та колбеків.

Приклад [покрокового створення тест рутини `numberIs`](./TestRoutineStepByStep.md#Тести-що-перевіряють-штатну-поведінку).

### Окремі змінні для тест кейсу

Для окремих тест кейсів мають використовуватись власні змінні. Це дозволяє ізолювати окремий тест кейс і тестувати його окремо.

```js
test.case = 'src is positive integer';
var src = 5;
var got = num.numberIs( src );
var expected = true;
test.identical( got, expected );

test.case = 'src is negative integer';
var src = -1 * src;
var got = num.numberIs( src );
test.identical( got, expected );
```

Приведений приклад показує два тест кейси. Перший з них має власні змінні `src`, `expected`, змінні і результат такого тест кейсу повністю незалежні. Другий тест кейс має змінну `src` котра використовує значення однойменної змінної із попереднього тест кейса. Також, тест залежний тест кейс використовує змінну `expected` незалежного тест кейса. Залежний тест кейс неможливо протестувати окремо від його залежностей. Якщо попередній тест кейс зміниться, або буде видалений, то результат залежного тест кейса зміниться, а може навіть викинути помилку.

### Що перевіряється чи яким має бути результат тест кейсу

Опис тест кейсу чи тест перевірки має явно вказувати на те, що перевіряється, чи яким має бути результат перевірки.

```js
test.case = 'null, null';
var got = _.arrayAppend( null, null );
var expected = [ null ];
test.identical( got, expected );
```

Рутина `arrayAppend` приймає два аргументи - `dst` i `ins`, вона додає другий аргумент в кінець масиву `dst`. Якщо `dst` має значення `null`, тоді створюється новий масив. Приведений тест кейс має поганий опис по двом причинам. По перше, з опису незрозуміло що перевіряється, чи які умови імплементовано. По друге, за можливості для опису краще використовувати не окремі значення, а цілі категорії.

Для приведеного тест кейсу опис може бути таким

```js
test.case = 'dst is null, ins is primitive';
```

Тест кейс описує умови тестування, тобто, що тестується. В назві явно указано назви аргументів, що полегшує зчитування інформації. Для аргументу `ins` використана категорія `primitive`, при заміні значення `null` на інший примітив результат буде аналогічним.

Опис тест кейсу може містити опис очікуваного результату

```js
test.case = 'dst is null, primitive appends to new container';
```

Для окремої тест рутини стиль опису має бути однаковим. Це дозволяє швидко орієнтуватись у послідовності тест кейсів.

### Опис тест кейсу має описувати різницю між цим тест кейсом та іншим

Опис відмінностей в початкових даних

```js
test.case = 'range[ 0 ] - 0, range[ 0 ] < range[ 1 ]';
// code of test case

test.case = 'range[ 0 ] - 0, range[ 0 ] === range[ 1 ]';
// code of test case
```

Опис відмінностей в результаті

```js
test.case = 'expects empty array';
// code of test case

test.case = 'saves 2 elements from start';
// code of test case
```

### Тест кейс тестує один з аспектів тест юніта

Кожен тест кейс тестує лише один з аспектів тест юніта. Поганою практикою є змішування двох тест кейсів в одному.

```js
test.case = 'expects empty array';
var dst1 = [];
var dst2 = [ 1, 1, 1 ];
var got = _.arrayRemove( dst1, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst1 );
var got = _.arrayRemove( dst2, 1 );
test.identical( got, expected );
test.is( got === dst2 );
```

Приведений тест кейс демонструє змішування двох тест кейсів. В обох очікується однаковий результат. Такий тест кейс складно читати, подібність викликів і отриманих результатів дезорієнтує. Указані тест кейси мають виглядати наступним чином:

```js
test.case = 'dst is empty array, expects empty array';
var dst = [];
var got = _.arrayRemove( dst, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst );

test.case = 'dst contains only searched element, expects empty array';
var dst = [ 1, 1, 1 ];
var got = _.arrayRemove( dst2, 1 );
var expected = [];
test.identical( got, expected );
test.is( got === dst2 );
```

Кожен тест кейс тестує одну із можливих ситуацій. Тест рутину легко читати і підтримувати.

Маркерами того, що йде змішування декількох тест кейсів є використання додаткових змінних, індексування змінних подібно указаним приставкам `dst1` i `dst2`, а також використання додаткових рутин для перевірки результату.

### Збитковість тест кейсів

```js
test.case = 'src is 5';
var src = 5;
var got = num.numberIs( src );
var expected = true;
test.identical( got, expected );


test.case = 'src is 1000';
var src = 1000;
var got = num.numberIs( src );
var expected = true;
test.identical( got, expected );
```

### Збитковість тест перевірок

```js
test.case = 'dst is null, ins is empty array';
var dst = null;
var ins = [];
var got = _.arrayAppend( dst, ins );
var expected = [ [] ];
test.identical( got, expected );
test.is( got !== dst );
test.is( got !== ins );
test.is( got[ 0 ] === ins );
```

### Рутина має бути читабельною, розміщення змінних на початку або в кінці

Розміщення змінних на початку або в кінці рутини.

```js
function prefixGet( test )
{
  var path1 = '',
      path2 = 'some.txt',
      // other paths
      expected1 = '',
      expected2 = 'some',
      // other expected values

  /* */

  test.case = 'empty path';
  var got = _.path.prefixGet( path1 );
  test.identical( got, expected1 );

  test.case = 'txt extension';
  var got = _.path.prefixGet( path2 );
  test.identical( got, expected2 );

  // other test cases
```

Виключення. Колбеки значного об'єму

```js
test.case = 'description of test case';
function longCallbac( src )
{
  if( _.numberIs( src ) )
  return 1;
  if( _.strIs( src ) )
  return 2;
  if( _.boolIs( src ) )
  return 3;
}
// code of test case
```

Дублювання такого колбеку не додає функціональності, проте погіршує читабельність.

### Кейс має бути читабельним, зайві елементи

```js
test.case = 'too many elements in container';
var src = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
var got = _.arrayAppend( src, 1 );
```

### Кейс має бути читабельним, нечитабельні результати

```js
test.case = 'unreadable expected variable';
var got = _.arrayMake( 3 );
var expected = [ ,, ];
```

### Діагностична інформація має бути інформативна, використання циклів

```js
var src =
[
  null,
  undefined,
  1,
  true,
  false,
  [],
  {}
];

for( let i = 0 ; i < src.length ; i++ )
{
  test.case = `src - ${ typeof src[ i ] }, expected - false`;
  var got = _.strIs( src[ i ] );
  test.identical( got, false );
}
```

### Уникати функціональних адаптерів

```js
test.case = 'src is number';
var got = _.argumentsArrayFrom( [ 1, 2, 3 ] );
var expected = [ 1, 2, 3 ];
test.equivalent( got, expected );
```
